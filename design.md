# Swimlanes.io MCP Server Design Document

## Overview

This document outlines the design for a Model Context Protocol (MCP) server that provides integration with the Swimlanes.io API. The MCP server will expose tools that allow AI assistants like GitHub Copilot to automatically analyze project codebases and generate swimlane diagrams and images programmatically.

### Primary Use Case

The main use case is enabling developers to ask Copilot questions like:
- "Using the SL_MCP Server, build me swim lane diagrams for this project"
- "Generate sequence diagrams showing the authentication flow in this codebase"
- "Create swimlane diagrams for the API endpoints in this service"

Copilot will analyze the project structure, understand the code flows, and automatically generate appropriate swimlane syntax to visualize the system architecture and interactions.

### "Markdown Wizard" Workflow

The system acts as a "markdown wizard" with this workflow:
1. **Analyze**: Copilot analyzes the current codebase structure and flows
2. **Generate**: Create swimlane syntax for the identified patterns
3. **Store**: Save both the swimlane syntax and rendered images as markdown files in the repo
4. **Version Control**: Check the documentation into GitHub for team collaboration

This approach treats Swimlanes.io as a rendering service while keeping the source diagrams as version-controlled text files.

## Technical Stack

### Language & Runtime

- **Language**: TypeScript
- **Runtime**: Node.js (≥18.0.0)
- **Rationale**:
  - TypeScript provides excellent type safety for MCP protocol implementation
  - Rich ecosystem for HTTP clients and JSON handling
  - Existing MCP SDK availability
  - Easy deployment and dependency management

### Key Dependencies

- `@modelcontextprotocol/sdk` - MCP protocol implementation
- `axios` - HTTP client for Swimlanes.io API calls
- `zod` - Runtime type validation for tool parameters
- `fs/promises` - File system operations for image saving

## Architecture Overview

```text
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────────┐
│   AI Assistant  │───▶│   MCP Server     │───▶│  Swimlanes.io API   │
│   (Claude, etc) │    │   (This Project) │    │                     │
└─────────────────┘    └──────────────────┘    └─────────────────────┘
                              │
                              ▼
                       ┌──────────────────┐
                       │   Local Files    │
                       │   (Images, etc)  │
                       └──────────────────┘
```

## MCP Tools Design

### Tool 1: `create_swimlane_documentation`

**Purpose**: The primary tool for the "markdown wizard" workflow. Generates a complete markdown documentation file with swimlane diagram syntax and embedded images, ready for version control.

**Parameters**:
```typescript
{
  text: string;              // Swimlanes syntax content
  title: string;             // Diagram title
  description?: string;      // Description of what the diagram represents
  outputPath?: string;       // Where to save markdown file (default: auto-generated)
  includeImage?: boolean;    // Whether to embed rendered image (default: true)
  folderStructure?: string;  // Optional folder organization (e.g., "auth", "api")
}
```

**Returns**:
```typescript
{
  success: boolean;
  markdownPath?: string;     // Path to generated markdown file
  imagePath?: string;        // Path to embedded image (if generated)
  diagramUrl?: string;       // Shareable swimlanes.io URL for reference
  content?: string;          // Generated markdown content
  error?: string;
}
```

**Generated Markdown Format**:
```markdown
# User Authentication Flow

*Sequence diagram showing OAuth2 authentication process in the user service*

## Diagram Source

```swimlanes
title: User Authentication Flow
Client -> AuthService: POST /oauth/token
AuthService -> Database: Validate credentials
Database -> AuthService: User data
AuthService -> TokenService: Generate JWT
TokenService -> AuthService: Signed token
AuthService -> Client: Access token + Refresh token
```

## Rendered Diagram

![User Authentication Flow](./images/auth-flow.png)

**Interactive Version**: [View on Swimlanes.io](https://swimlanes.io/#...)

---
*Generated by SL_MCP Server on 2025-07-21*
```

**REST API Mapping**: `POST /link` + `POST /image`

**Example Usage for Project Analysis**:

```typescript
// After Copilot analyzes an authentication service
create_swimlane_documentation({
  title: "User Authentication Flow",
  description: "Sequence diagram showing OAuth2 authentication process in the user service",
  text: "Client -> AuthService: POST /oauth/token\nAuthService -> Database: Validate credentials\nDatabase -> AuthService: User data\nAuthService -> TokenService: Generate JWT\nTokenService -> AuthService: Signed token\nAuthService -> Client: Access token + Refresh token",
  outputPath: "./docs/diagrams/auth-flow.md",
  folderStructure: "auth"
})
```

### Tool 2: `generate_swimlane_image`

**Purpose**: Generate and save a PNG image of a swimlane diagram

**Parameters**:
```typescript
{
  text: string;              // Swimlanes syntax content
  title?: string;            // Optional title
  highResolution?: boolean;  // For printing quality (default: false)
  outputPath?: string;       // Where to save (default: auto-generated)
}
```

**Returns**:
```typescript
{
  success: boolean;
  imagePath?: string;        // Local file path to saved PNG
  imageUrl?: string;         // Direct URL to image (temporary)
  error?: string;
}
```

**REST API Mapping**: `POST /image` (with redirect follow)

**Example Usage**:
```
generate_swimlane_image({
  text: "A -> B: Deploy\nB -> C: Verify",
  title: "Deployment Process",
  highResolution: true,
  outputPath: "./diagrams/deployment.png"
})
```

### Tool 3: `get_swimlane_image_link`

**Purpose**: Generate a direct link to a PNG image without downloading

**Parameters**:
```typescript
{
  text: string;              // Swimlanes syntax content
  title?: string;            // Optional title
  highResolution?: boolean;  // For printing quality (default: false)
}
```

**Returns**:
```typescript
{
  success: boolean;
  imageUrl?: string;         // Direct URL to hosted PNG image
  error?: string;
}
```

**REST API Mapping**: `POST /image-link`

**Example Usage**:
```
get_swimlane_image_link({
  text: "User -> System: Login\nSystem -> DB: Validate",
  title: "Authentication Flow"
})
```

## Copilot Integration & Project Analysis

### Typical Workflow

1. **User Request**: "Using the SL_MCP Server, build me swim lane diagrams for this project"
2. **Copilot Analysis**: Copilot analyzes the codebase structure, APIs, and flows
3. **Diagram Generation**: Copilot generates appropriate swimlanes syntax for different aspects
4. **MCP Tool Calls**: Multiple calls to `create_swimlane_diagram` for different flows
5. **Result Presentation**: Copilot presents the shareable links with descriptions

### Common Project Analysis Patterns

#### API Endpoint Flows
Copilot will analyze REST/GraphQL endpoints and generate sequence diagrams showing:
- Request/response flows
- Authentication/authorization steps
- Database interactions
- External service calls
- Error handling paths

#### Service Architecture
For microservices or distributed systems:
- Inter-service communication
- Message queue flows
- Event-driven patterns
- Load balancer routing

#### User Journeys
Frontend applications and user workflows:
- Authentication flows
- CRUD operations
- Navigation patterns
- State management

#### Data Processing Pipelines
Backend data flows:
- ETL processes
- Stream processing
- Batch operations
- Data validation steps

### Enhanced Tools for Project Analysis

While the three core tools handle diagram generation, Copilot will leverage its codebase analysis capabilities to:

1. **Identify Key Flows**: Automatically detect important system interactions
2. **Extract Entities**: Find services, controllers, models, and components
3. **Trace Dependencies**: Follow call chains and data flows
4. **Generate Appropriate Syntax**: Convert code patterns into swimlanes syntax
5. **Create Multiple Views**: Generate different diagrams for different aspects

### Example Project Analysis Results

Given a typical Express.js API project, Copilot might generate:

1. **Authentication Flow Diagram**
2. **User Registration Process**
3. **API Request Lifecycle**
4. **Database Transaction Flow**
5. **Error Handling Sequences**

Each would be a separate call to `create_swimlane_diagram` with descriptive titles and context.

### Input Processing
- Accept raw swimlanes syntax as strings
- Support optional title parameter that gets prepended as `title: {title}\n` to the syntax
- Validate basic syntax structure before API calls
- Handle line breaks correctly (`\n` separation as required by API)

### Syntax Reference
The MCP server will support the full Swimlanes.io syntax as documented at: https://swimlanes.io/gallery/full-syntax

Common patterns to support:
```
title: Diagram Title
A -> B: Message
B -> A: Response
note over A: Internal process
A -> C: Async call
```

## Error Handling Strategy

### API Error Mapping
- **400 Bad Request**: Return clear syntax error messages to help users fix their input
- **504 Timeout**: Suggest retry with exponential backoff
- **Network Errors**: Provide connectivity troubleshooting guidance

### Validation
- Pre-validate swimlanes syntax locally where possible
- Validate file paths and permissions before API calls
- Provide helpful error messages with suggested fixes

### Error Response Format
```typescript
{
  success: false,
  error: "Human-readable error message",
  errorCode?: "SYNTAX_ERROR" | "NETWORK_ERROR" | "TIMEOUT" | "FILE_ERROR",
  suggestions?: string[]  // Suggested fixes
}
```

## File Management & Version Control Integration

### Documentation Structure

The MCP server will create a well-organized documentation structure that's ideal for version control:

```text
docs/
├── diagrams/
│   ├── auth/
│   │   ├── login-flow.md
│   │   ├── registration-flow.md
│   │   └── images/
│   │       ├── login-flow.png
│   │       └── registration-flow.png
│   ├── api/
│   │   ├── request-lifecycle.md
│   │   ├── error-handling.md
│   │   └── images/
│   │       ├── request-lifecycle.png
│   │       └── error-handling.png
│   └── architecture/
│       ├── microservices-communication.md
│       └── images/
│           └── microservices-communication.png
```

### Markdown File Format

Each generated markdown file includes:

1. **Title and Description**: Clear documentation of what the diagram represents
2. **Swimlanes Source**: The raw swimlanes syntax in a code block for easy editing
3. **Rendered Image**: PNG image for immediate viewing in GitHub/IDEs
4. **Interactive Link**: Link to Swimlanes.io for dynamic viewing and editing
5. **Metadata**: Generation timestamp and tool information

### Version Control Benefits

- **Text-based**: Swimlanes syntax is plain text, perfect for git diffs
- **Searchable**: Diagram content is searchable in GitHub and IDEs
- **Editable**: Team members can edit diagrams by modifying the syntax
- **Reviewable**: Diagram changes show up in pull requests
- **Portable**: No dependency on external services for viewing

### File Naming Convention

```text
{category}/{descriptive-name}.md
auth/user-login-flow.md
api/rest-endpoint-lifecycle.md
architecture/service-communication.md
```

### Auto-generated Content Template

```markdown
# {Title}

*{Description}*

## Overview

This diagram was automatically generated from the codebase analysis.

## Diagram Source

```swimlanes
{swimlanes-syntax}
```

## Visual Representation

![{Title}](./images/{filename}.png)

**Interactive Version**: [Edit on Swimlanes.io]({swimlanes-url})

## Related Files

- Source analysis based on: `{analyzed-files}`

---
*Auto-generated by SL_MCP Server on {timestamp}*
```

## Implementation Phases

### Phase 1: Core Functionality
- [ ] Basic MCP server setup with TypeScript
- [ ] Implement `create_swimlane_diagram` tool
- [ ] Basic error handling and validation
- [ ] Unit tests for core functionality

### Phase 2: Image Generation
- [ ] Implement `generate_swimlane_image` tool
- [ ] File management and storage
- [ ] Implement `get_swimlane_image_link` tool
- [ ] Integration tests with Swimlanes.io API

### Phase 3: Enhanced Features
- [ ] Advanced syntax validation
- [ ] Caching for frequently generated diagrams
- [ ] Configuration options
- [ ] Documentation and examples

### Phase 4: Production Readiness
- [ ] Comprehensive error handling
- [ ] Logging and monitoring
- [ ] Performance optimization
- [ ] Security considerations

## Configuration

### Environment Variables
```bash
SWIMLANES_OUTPUT_DIR=./swimlane_images  # Default image output directory
SWIMLANES_CACHE_TTL=3600               # Cache TTL in seconds
SWIMLANES_MAX_FILE_SIZE=10MB           # Max image file size
```

### Optional Features
- Diagram caching to avoid redundant API calls
- Custom templates for common diagram patterns
- Batch processing for multiple diagrams

## Usage Examples

### Example 1: Complete Documentation Generation for Express.js API

**User Request**: "Using the SL_MCP Server, build me swim lane diagrams for this project"

**Copilot Analysis**: Copilot examines the Express.js routes, middleware, and database models

**Generated Documentation Files**:

```typescript
// Authentication Flow Documentation
create_swimlane_documentation({
  title: "User Authentication Process",
  description: "OAuth2 login flow with JWT token generation",
  text: "title: User Authentication Process\nClient -> AuthController: POST /auth/login\nAuthController -> ValidationMiddleware: Validate input\nValidationMiddleware -> AuthController: Input validated\nAuthController -> UserService: authenticateUser()\nUserService -> Database: SELECT user WHERE email\nDatabase -> UserService: User record\nUserService -> BcryptUtil: comparePassword()\nBcryptUtil -> UserService: Password valid\nUserService -> JWTService: generateToken()\nJWTService -> UserService: JWT token\nUserService -> AuthController: Authentication success\nAuthController -> Client: 200 + JWT token",
  outputPath: "./docs/diagrams/auth/login-flow.md",
  folderStructure: "auth"
})

// API Request Lifecycle Documentation
create_swimlane_documentation({
  title: "Protected API Request Flow",
  description: "How authenticated requests are processed",
  text: "title: Protected API Request Flow\nClient -> ExpressApp: GET /api/profile\nExpressApp -> AuthMiddleware: Verify JWT\nAuthMiddleware -> JWTService: validateToken()\nJWTService -> AuthMiddleware: Token valid + user data\nAuthMiddleware -> ProfileController: Request with user context\nProfileController -> UserService: getUserProfile()\nUserService -> Database: SELECT profile WHERE userId\nDatabase -> UserService: Profile data\nUserService -> ProfileController: User profile\nProfileController -> Client: 200 + profile JSON",
  outputPath: "./docs/diagrams/api/request-lifecycle.md",
  folderStructure: "api"
})
```

**Result**: Two markdown files created in organized folders, ready for git commit and team collaboration.

### Example 2: Project Documentation Set

**User Request**: "Generate complete swimlane documentation for our microservices"

**Generated Files Structure**:
```text
docs/diagrams/
├── architecture/
│   └── service-communication.md
├── orders/
│   └── order-processing.md
└── notifications/
    └── email-flow.md
```

**Each file contains**:
- Editable swimlanes syntax
- Rendered PNG image
- Interactive Swimlanes.io link
- Metadata for maintenance

### Example 3: Documentation Update Workflow

**Scenario**: Developer modifies authentication flow

1. **Edit**: Developer edits `./docs/diagrams/auth/login-flow.md`
2. **Update**: Modify the swimlanes syntax in the markdown file
3. **Regenerate**: Run MCP tool to update the rendered image
4. **Commit**: Git shows both text and image changes in the diff
5. **Review**: Team reviews changes in pull request

**Command**:
```typescript
create_swimlane_documentation({
  title: "User Authentication Process",
  description: "Updated OAuth2 login flow with 2FA support", 
  text: "title: Updated User Authentication Process\nClient -> AuthController: POST /auth/login\nAuthController -> ValidationMiddleware: Validate input\nValidationMiddleware -> AuthController: Input validated\nAuthController -> UserService: authenticateUser()\nUserService -> Database: SELECT user WHERE email\nDatabase -> UserService: User record\nUserService -> BcryptUtil: comparePassword()\nBcryptUtil -> UserService: Password valid\nUserService -> TwoFactorService: Verify 2FA code\nTwoFactorService -> UserService: 2FA verified\nUserService -> JWTService: generateToken()\nJWTService -> UserService: JWT token\nUserService -> AuthController: Authentication success\nAuthController -> Client: 200 + JWT token",
  outputPath: "./docs/diagrams/auth/login-flow.md"  // Updates existing file
})
```

## Testing Strategy

### Unit Tests
- Tool parameter validation
- Syntax parsing and preprocessing
- Error handling scenarios
- File operations

### Integration Tests
- Live API calls to Swimlanes.io (with rate limiting)
- End-to-end diagram generation
- File system integration

### Mock Testing
- Simulated API responses for consistent testing
- Network failure scenarios
- Large diagram handling

## Security Considerations

### Input Validation
- Sanitize all user input before API calls
- Validate file paths to prevent directory traversal
- Limit maximum input size to prevent abuse

### API Security
- No authentication required for Swimlanes.io API (public service)
- Implement rate limiting to respect service limits
- Consider caching to reduce API load

### File Security
- Validate output paths to prevent writing outside designated directories
- Set appropriate file permissions on generated images
- Clean up temporary files to prevent disk space issues

## Future Enhancements

### Potential Features
- Support for swimlanes themes and styling
- Integration with version control for diagram history
- Export to multiple formats (SVG, PDF)
- Collaborative editing through shared links
- Template library for common patterns

### Performance Optimizations
- Response caching based on content hash
- Async image processing for large diagrams
- Streaming responses for real-time feedback

## Questions for Resolution

1. **Language Choice**: Confirmed TypeScript/Node.js for rapid development and MCP ecosystem compatibility?
2. **Diagram Complexity**: Should we add limits on diagram size/complexity to ensure good rendering performance?
3. **Caching Strategy**: Given the project analysis use case, should we implement content-based caching to avoid regenerating identical diagrams?
4. **File Organization**: For projects that generate multiple diagrams, should we create organized folder structures (e.g., `./diagrams/auth/`, `./diagrams/api/`)?
5. **Integration Scope**: Should the MCP server include any helper functions for common project analysis patterns, or rely entirely on Copilot's analysis capabilities?

## Implementation Priority

Given the primary use case of Copilot project analysis, the implementation priority should be:

### Phase 1 (MVP for Copilot Integration)
- [ ] Core `create_swimlane_diagram` tool with title and description support
- [ ] Basic error handling and validation
- [ ] TypeScript types and MCP server setup

### Phase 2 (Enhanced Project Analysis Support)
- [ ] Image generation tools for documentation embedding
- [ ] Improved error messages for common syntax issues
- [ ] Basic caching to improve performance for repeated analysis

### Phase 3 (Production Features)
- [ ] Advanced file organization
- [ ] Performance optimization
- [ ] Comprehensive testing

This prioritization ensures Copilot can start generating useful diagrams quickly while building toward a robust production system.

---

*This design document is a living document and will be updated as the project evolves and requirements are clarified.*
